generator client {
  provider = "prisma-client-js"
  // output = "../generated/client"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                 String                  @id @default(uuid())
  email              String                  @unique
  username           String                  @unique
  hashedPassword     String
  salt               String                  @default("")
  createdAt          DateTime                @default(now())
  lastActiveAt       DateTime                @default(now())
  avatarUrl          String?
  secret2FA          String?
  enabled2FA         Boolean                 @default(false)
  friendsSent        Friendship[]            @relation("SentRequests")
  friendsReceived    Friendship[]            @relation("ReceivedRequests")
  matches1           Match[]                 @relation("MatchUser1")
  matches2           Match[]                 @relation("MatchUser2")
  matchesWon         Match[]                 @relation("MatchWinner")
  leaderboard        Leaderboard[]
  tournaments        TournamentParticipant[]
}

model Leaderboard {
  id     String @id @default(uuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
  score  Int    @default(0)
}

model Friendship {
  id          String           @id @default(uuid())
  initiator   User             @relation("SentRequests", fields: [initiatorId], references: [id], onDelete: Cascade)
  initiatorId String
  recipient   User             @relation("ReceivedRequests", fields: [recipientId], references: [id], onDelete: Cascade)
  recipientId String
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @default(now()) @updatedAt
  status      FriendshipStatus @default(PENDING)

  @@unique([initiatorId, recipientId])
  @@unique([recipientId, initiatorId])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

// TODO: Review if updatedAt is necessary
model Match {
  id             String      @id @default(uuid())
  mode           GameMode   @default(CLASSIC)
  user1Id        String
  user1          User        @relation("MatchUser1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2Id        String
  user2          User        @relation("MatchUser2", fields: [user2Id], references: [id], onDelete: Cascade)
  user1Score     Int         @default(0)
  user2Score     Int         @default(0)
  user1Character Character?
  user2Character Character?
  winnerId       String?
  winner         User?       @relation("MatchWinner", fields: [winnerId], references: [id], onDelete: Cascade)
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @default(now()) @updatedAt
  settings       String
}

enum Character {
  NONE
  MARIO
  LINK
  PIKACHU
  SONIC
  KIRBY
  YOSHI
  DK
  MEWTWO
  BOWSER
  SAMUS
  CAPFALCON
  SNAKE
}

enum GameMode {
  CLASSIC
  CRAZY
}

model TournamentParticipant {
  id             String     @id @default(uuid())
  tournamentId   String
  tournamentType GameMode
  user           User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId         String
  alias          String
  character      Character?

  @@unique([tournamentId, userId])
  // @@unique([tournamentId, alias])
}
